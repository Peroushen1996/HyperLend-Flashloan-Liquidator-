// bot/src/index.js
require("dotenv").config();
const axios = require("axios");
const cron = require("node-cron");
const { ethers } = require("ethers");
const fs = require("fs");
const path = require("path");

// --------------------
// Tunables (in-code)
// --------------------
const CLOSE_FACTOR = 0.5;
const FLASH_LOAN_FEE = 9; // bps

// If you don't have USD pricing wired yet, rely on sim/staticCall instead of this.
const MIN_LIQUIDATION_VALUE_USD = 1; // placeholder
const MIN_PROFIT_THRESHOLD_BPS = 1;

const MAX_WALLETS_PER_CYCLE = 100;

const COOLDOWN_MS = 12 * 60 * 60 * 1000;
const COOLDOWN_SUCCESS_MS = 24 * 60 * 60 * 1000;

const MAX_RETRIES_PER_WALLET = 3;
const RETRY_COOLDOWN_MS = 60 * 60 * 1000;

const GAS_LIMIT_MULTIPLIER = 1.3;

const MAX_CONCURRENT_SIMS = 3;
const MAX_CONCURRENT_SENDS = 1;

// API timeouts
const ROUTE_TIMEOUT_MS = 15000;
const RPC_TIMEOUT_MS = 25000;

// Try a few size guesses for the router quote if your collateral estimate is off.
const QUOTE_SIZE_FACTORS = [0.9, 1.0, 1.1];

// --------------------
// Imports
// --------------------
const {
  getDetailedPositionFromAPI,
  getLiquidatableWallets,
  getMarketMetaByUnderlying,
} = require("./utils/positions");

// --------------------
// State
// --------------------
let cachedWallet = null; // Wallet (NOT connected) after decrypt
let cachedRouter = null;

const cooldowns = new Map(); // wallet -> cooldownUntilMs
const retryAttempts = new Map(); // wallet -> attemptCount

let activeSims = 0;
let activeSends = 0;

let RUNNING = false;

const cycleStats = {
  processed: 0,
  successful: 0,
  notLiquidatable: 0,
  insufficientSize: 0,
  noLiquidity: 0,
  simFailed: 0,
  txFailed: 0,
};

// Minimal pool reads + AddressesProvider + Oracle
const poolAbi = [
  "function getUserAccountData(address user) view returns (uint256,uint256,uint256,uint256,uint256,uint256)",
  "function ADDRESSES_PROVIDER() view returns (address)",
  "function getAddressesProvider() view returns (address)",
];
const addressesProviderAbi = ["function getPriceOracle() view returns (address)"];
const priceOracleAbi = ["function getAssetPrice(address asset) view returns (uint256)"];

const liquidatorReadAbi = ["function liquidSwapRouter() view returns (address)"];

// --------------------
// RPC rotation (hardened)
// --------------------
const HYPEREVM_NETWORK = new ethers.Network("hyperEvm", 999);

function parseRpcList() {
  const fallbacks = String(process.env.RPC_FALLBACKS || "")
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);

  const list = [process.env.SEND_RPC, ...fallbacks].filter(Boolean);

  // de-dupe preserving order
  const seen = new Set();
  const out = [];
  for (const url of list) {
    if (!seen.has(url)) {
      seen.add(url);
      out.push(url);
    }
  }
  return out.length ? out : [process.env.SEND_RPC].filter(Boolean);
}

const RPCS = parseRpcList();
let rpcIdx = 0;

function buildProvider(url) {
  return new ethers.JsonRpcProvider(url, HYPEREVM_NETWORK, { staticNetwork: HYPEREVM_NETWORK });
}

let provider = buildProvider(RPCS[rpcIdx]);

function rotateRpc(reason) {
  if (RPCS.length <= 1) return provider;
  rpcIdx = (rpcIdx + 1) % RPCS.length;
  provider = buildProvider(RPCS[rpcIdx]);
  console.log(`   [RPC] Rotated -> #${rpcIdx} ${RPCS[rpcIdx]}${reason ? ` (${reason})` : ""}`);
  return provider;
}

function getProvider() {
  return provider;
}

function isRetryableRpcError(e) {
  const msg = String(e?.message || "");
  const code = String(e?.code || "");
  const short = String(e?.shortMessage || "");

  return (
    msg.includes("timeout") ||
    msg.includes("rate limited") ||
    msg.includes("429") ||
    msg.includes("502") ||
    msg.includes("Bad Gateway") ||
    msg.includes("503") ||
    msg.includes("504") ||
    msg.includes("Gateway Timeout") ||
    msg.includes("socket hang up") ||
    msg.includes("missing response") ||
    msg.includes("ECONNRESET") ||
    msg.includes("ETIMEDOUT") ||
    msg.includes("ENOTFOUND") ||
    code === "BAD_DATA" ||
    code === "UNKNOWN_ERROR" ||
    short.includes("missing response")
  );
}

async function withRpcRetry(fn, tries = 3, label = "rpc") {
  let lastErr;
  for (let i = 0; i < tries; i++) {
    try {
      const res = await Promise.race([
        fn(getProvider()),
        new Promise((_, reject) => setTimeout(() => reject(new Error("RPC timeout")), RPC_TIMEOUT_MS)),
      ]);
      return res;
    } catch (e) {
      lastErr = e;
      const retryable = isRetryableRpcError(e);
      const msg = String(e?.shortMessage || e?.message || e);

      console.log(`   ‚ö†Ô∏è  ${label} attempt ${i + 1}/${tries} failed: ${msg.slice(0, 140)}`);

      if (retryable) {
        rotateRpc("retryable error");
      }

      if (i < tries - 1) {
        const backoff = Math.min(1000 * Math.pow(2, i), 10000);
        await new Promise((r) => setTimeout(r, backoff));
      }
    }
  }
  throw lastErr;
}

// --------------------
// Helpers: signer / contracts
// --------------------
function getSigner() {
  if (!cachedWallet) return null;
  // Always connect to current provider (important when rotating RPCs)
  return cachedWallet.connect(getProvider());
}

function getPoolRead() {
  return new ethers.Contract(process.env.POOL_ADDRESS, poolAbi, getProvider());
}

// --------------------
// Price oracle cache
// --------------------
let cachedOracle = null;
let cachedOracleAt = 0;

async function getPriceOracle() {
  const ttlMs = 10 * 60 * 1000;
  const now = Date.now();
  if (cachedOracle && now - cachedOracleAt < ttlMs) return cachedOracle;

  const pool = getPoolRead();
  let providerAddr = null;

  // HyperLend is Aave-like; try both getters.
  try {
    providerAddr = await withRpcRetry(async () => pool.ADDRESSES_PROVIDER(), 2, "ADDRESSES_PROVIDER");
  } catch {}
  if (!providerAddr) {
    try {
      providerAddr = await withRpcRetry(async () => pool.getAddressesProvider(), 2, "getAddressesProvider");
    } catch {}
  }

  if (!providerAddr || providerAddr === ethers.ZeroAddress) {
    cachedOracle = null;
    return null;
  }

  const ap = new ethers.Contract(providerAddr, addressesProviderAbi, getProvider());
  const oracleAddr = await withRpcRetry(async () => ap.getPriceOracle(), 2, "getPriceOracle");

  if (!oracleAddr || oracleAddr === ethers.ZeroAddress) {
    cachedOracle = null;
    return null;
  }

  cachedOracle = new ethers.Contract(oracleAddr, priceOracleAbi, getProvider());
  cachedOracleAt = now;
  return cachedOracle;
}

function pow10(n) {
  return 10n ** BigInt(n);
}

/**
 * Estimate seized collateral (raw units) for a given debtToCover (raw units),
 * using on-chain prices + liquidation bonus from markets API (fallback to 5%).
 *
 * valueDebtBase = debtRaw * priceDebt / 10^debtDecimals
 * collatRaw ~= valueDebtBase * 10^collatDecimals / priceCollat * bonus
 */
async function estimateCollateralInRaw(debtRaw, debtDec, debtAsset, collatDec, collateralAsset) {
  const oracle = await getPriceOracle();
  if (!oracle) return null;

  const [priceDebt, priceCollat] = await Promise.all([
    withRpcRetry(async () => oracle.getAssetPrice(debtAsset), 2, "getAssetPrice(debt)"),
    withRpcRetry(async () => oracle.getAssetPrice(collateralAsset), 2, "getAssetPrice(collateral)"),
  ]);

  if (priceDebt === 0n || priceCollat === 0n) return null;

  const collMeta = getMarketMetaByUnderlying?.(collateralAsset);

  // Aave-style bonus is usually 10000 = no bonus, 10500 = +5%
  const bonusBps = BigInt(
    (collMeta && Number.isFinite(collMeta.liquidationBonusBps) && collMeta.liquidationBonusBps > 0)
      ? collMeta.liquidationBonusBps
      : 10500
  );

  const valueDebtBase = (debtRaw * priceDebt) / pow10(debtDec); // base currency wei
  let collatRaw = (valueDebtBase * pow10(collatDec)) / priceCollat;
  collatRaw = (collatRaw * bonusBps) / 10000n;

  // add a tiny buffer to reduce under-estimation risk
  collatRaw = (collatRaw * 101n) / 100n; // +1%
  return collatRaw;
}

// --------------------
// Logging
// --------------------
console.log("=== ENV DEBUG ===");
console.log("SEND_RPC        :", process.env.SEND_RPC || "MISSING");
console.log("RPC_FALLBACKS   :", process.env.RPC_FALLBACKS || "(none)");
console.log("POOL_ADDRESS    :", process.env.POOL_ADDRESS || "MISSING");
console.log("LIQUIDATOR      :", process.env.LIQUIDATOR || "MISSING");
console.log("PROFIT_RECEIVER :", process.env.PROFIT_RECEIVER || "MISSING");
console.log("=================\n");

// --------------------
// Keystore unlock
// --------------------
async function initializeSigner() {
  // quick sanity: provider alive
  await withRpcRetry(async (p) => p.getBlockNumber(), 2, "rpc preflight");

  while (!cachedWallet) {
    try {
      const keystoreName = "privateKey";
      const keystorePath = path.resolve(
        process.env.HOME || process.env.USERPROFILE,
        ".foundry/keystores",
        keystoreName
      );

      if (!fs.existsSync(keystorePath)) {
        console.error(`Keystore file not found: ${keystorePath}`);
        await new Promise((r) => setTimeout(r, 5000));
        continue;
      }

      const keystoreJson = JSON.parse(fs.readFileSync(keystorePath, "utf8"));

      console.log("Enter your keystore password (input will be invisible):");
      process.stdin.setRawMode(true);
      process.stdin.resume();
      process.stdin.setEncoding("utf8");

      let password = "";
      let done = false;

      const onData = (key) => {
        if (key === "\n" || key === "\r") {
          done = true;
          process.stdin.setRawMode(false);
          process.stdin.pause();
          console.log();
          process.stdin.removeListener("data", onData);
          return;
        }
        if (key === "\u007f" || key === "\b") {
          if (password.length > 0) password = password.slice(0, -1);
          return;
        }
        if (key.charCodeAt(0) < 32) return;
        password += key;
      };

      process.stdin.on("data", onData);

      await new Promise((resolve) => {
        const checkDone = () => (done ? resolve() : setTimeout(checkDone, 100));
        checkDone();
      });

      // Decrypt (no provider yet)
      cachedWallet = await ethers.Wallet.fromEncryptedJson(JSON.stringify(keystoreJson), password);

      // Router cache (read-only via RPC retry)
      try {
        const liq = new ethers.Contract(process.env.LIQUIDATOR, liquidatorReadAbi, getProvider());
        cachedRouter = (await withRpcRetry(async () => liq.liquidSwapRouter(), 3, "read liquidSwapRouter")).toLowerCase();
      } catch {
        cachedRouter = null;
      }

      console.log(`\nSuccess! Signer address: ${await getSigner().getAddress()}`);
      if (cachedRouter) console.log(`Router (from Liquidator): ${cachedRouter}`);
      console.log("Bot unlocked.\n");
    } catch (err) {
      cachedWallet = null;
      console.error("Decryption failed:", err.message);
      console.log("Try again.\n");
    }
  }

  return getSigner();
}

// --------------------
// On-chain HF check
// --------------------
async function isLiquidatableOnchain(user) {
  try {
    const pool = getPoolRead();
    const data = await withRpcRetry(async () => pool.getUserAccountData(user), 3, "getUserAccountData");
    const hf = data[5];
    const ONE = ethers.parseUnits("1", 18);
    return hf > 0n && hf < ONE;
  } catch {
    return false;
  }
}

// --------------------
// Profit calc (bps)
// profit_bps = (amountOut - debt - fee) / debt * 10000
// --------------------
function calculateProfitBps(amountOutBI, debtAmountBI) {
  const premiumBI = (debtAmountBI * BigInt(FLASH_LOAN_FEE)) / 10000n;
  const totalOwedBI = debtAmountBI + premiumBI;
  if (amountOutBI < totalOwedBI) return -10000;
  const profitBI = amountOutBI - totalOwedBI;
  return Number((profitBI * 10000n) / debtAmountBI);
}

// --------------------
// Tx execution (sim + send) with concurrency gates
// --------------------
async function sendTxWithCalldata(user, collateral, debt, debtAmount, swapCalldata) {
  // sim gate
  while (activeSims >= MAX_CONCURRENT_SIMS) {
    await new Promise((r) => setTimeout(r, 300));
  }
  activeSims++;

  try {
    const signer = getSigner();
    const abi = [
      "function liquidateWithCalldata(address _user, address _collateral, address _debt, uint256 _debtAmount, bytes _swapCalldata)",
    ];
    const contract = new ethers.Contract(process.env.LIQUIDATOR, abi, signer);

    console.log(`   üß™ Simulating (staticCall)...`);
    try {
      await withRpcRetry(
        async () => contract.liquidateWithCalldata.staticCall(user, collateral, debt, debtAmount, swapCalldata),
        2,
        "staticCall"
      );
      console.log(`   ‚úÖ Simulation passed`);
    } catch (simErr) {
      const msg = simErr?.shortMessage || simErr?.message || String(simErr);
      console.log(`   ‚ùå Simulation failed: ${msg.slice(0, 220)}`);
      cycleStats.simFailed++;
      cooldowns.set(user, Date.now() + RETRY_COOLDOWN_MS);
      return;
    }

    console.log(`   ‚õΩ Estimating gas...`);
    let gasEstimate;
    try {
      gasEstimate = await withRpcRetry(
        async () => contract.liquidateWithCalldata.estimateGas(user, collateral, debt, debtAmount, swapCalldata),
        2,
        "estimateGas"
      );
      console.log(`   ‚õΩ Gas estimate: ${gasEstimate.toString()}`);
    } catch (gasErr) {
      const msg = gasErr?.shortMessage || gasErr?.message || String(gasErr);
      console.log(`   ‚ùå Gas estimation failed: ${msg.slice(0, 220)}`);
      cycleStats.txFailed++;
      cooldowns.set(user, Date.now() + RETRY_COOLDOWN_MS);
      return;
    }

    // send gate
    while (activeSends >= MAX_CONCURRENT_SENDS) {
      await new Promise((r) => setTimeout(r, 500));
    }
    activeSends++;

    try {
      const gasLimit = (gasEstimate * BigInt(Math.round(GAS_LIMIT_MULTIPLIER * 100))) / 100n;

      console.log(`   üì§ Sending tx...`);
      const tx = await withRpcRetry(
        async () =>
          contract.liquidateWithCalldata(user, collateral, debt, debtAmount, swapCalldata, { gasLimit }),
        2,
        "sendTx"
      );

      console.log(`   ‚úÖ Tx sent: ${tx.hash}`);
      const receipt = await withRpcRetry(async () => tx.wait(), 2, "waitReceipt");
      console.log(`   ‚úÖ Confirmed in block ${receipt.blockNumber}`);

      cycleStats.successful++;
      retryAttempts.delete(user);
      cooldowns.set(user, Date.now() + COOLDOWN_SUCCESS_MS);
      console.log(`   üéâ Liquidation successful!`);
    } catch (sendErr) {
      const msg = sendErr?.shortMessage || sendErr?.message || String(sendErr);
      console.log(`   ‚ùå Tx failed: ${msg.slice(0, 240)}`);

      const attempts = (retryAttempts.get(user) || 0) + 1;
      retryAttempts.set(user, attempts);

      if (attempts < MAX_RETRIES_PER_WALLET) {
        cooldowns.set(user, Date.now() + RETRY_COOLDOWN_MS);
      } else {
        cooldowns.set(user, Date.now() + COOLDOWN_MS);
      }

      cycleStats.txFailed++;
    } finally {
      activeSends--;
    }
  } finally {
    activeSims--;
  }
}

// --------------------
// Main loop
// --------------------
async function run() {
  if (RUNNING) {
    console.log("‚è≥ Previous run still active ‚Äî skipping this tick");
    return;
  }
  RUNNING = true;

  try {
    Object.assign(cycleStats, {
      processed: 0,
      successful: 0,
      notLiquidatable: 0,
      insufficientSize: 0,
      noLiquidity: 0,
      simFailed: 0,
      txFailed: 0,
    });

    const wallets = await getLiquidatableWallets();

    if (!wallets || wallets.length === 0) {
      console.log(`[${new Date().toISOString()}] No liquidatable wallets found. Waiting...\n`);
      return;
    }

    wallets.sort((a, b) => parseFloat(a.health_rate) - parseFloat(b.health_rate));
    const walletsToProcess = wallets.slice(0, MAX_WALLETS_PER_CYCLE);

    console.log(
      `\n[${new Date().toISOString()}] Found ${wallets.length} liquidatable wallets. Processing ${walletsToProcess.length}...\n`
    );

    for (const wallet of walletsToProcess) {
      const addr = wallet.wallet_address;
      const now = Date.now();

      const cooldownUntil = cooldowns.get(addr);
      if (cooldownUntil && now < cooldownUntil) continue;

      try {
        console.log(`\nüí∞ Processing: ${addr} | HF=${wallet.health_rate}`);

        const positions = await getDetailedPositionFromAPI(wallet);
        if (!positions?.supply?.length || !positions?.borrow?.length) {
          console.log(`   ‚ö†Ô∏è  No supply/borrow positions found, skipping`);
          continue;
        }

        const supplyCandidates = positions.supply
          .map((p) => {
            const dec = Number(p.decimals) || 18;
            const human = Number(ethers.formatUnits(p.amount, dec));
            return { underlying: p.underlying, symbol: p.symbol, decimals: dec, amount: p.amount, humanAmount: human };
          })
          .sort((a, b) => b.humanAmount - a.humanAmount);

        const borrowCandidates = positions.borrow
          .map((p) => {
            const dec = Number(p.decimals) || 18;
            const human = Number(ethers.formatUnits(p.amount, dec));
            return { underlying: p.underlying, symbol: p.symbol, decimals: dec, amount: p.amount, humanAmount: human };
          })
          .sort((a, b) => b.humanAmount - a.humanAmount);

        // Try multiple pairs until one sim passes (more robust than "largest token amount")
        const pairsToTry = [];
        for (const s of supplyCandidates.slice(0, 8)) {
          for (const b of borrowCandidates.slice(0, 8)) {
            if (s.underlying.toLowerCase() === b.underlying.toLowerCase()) continue;
            pairsToTry.push([s, b]);
          }
        }

        if (!pairsToTry.length) {
          console.log(`   ‚ö†Ô∏è  No valid supply/borrow pair found, skipping`);
          continue;
        }

        cycleStats.processed++;
        let sent = false;
        for (const pair of pairsToTry) {
          sent = await prepareAndSend(wallet, pair);
          if (sent) break;
        }

        if (!sent) {
          // cooldown so we don't hammer same wallet endlessly
          cooldowns.set(addr, Date.now() + RETRY_COOLDOWN_MS);
        }
      } catch (e) {
        console.log(`‚ùå Error processing ${addr}: ${e.message}`);
        cycleStats.txFailed++;
      }
    }

    console.log(
      `\nüìä Cycle stats: processed=${cycleStats.processed}, success=${cycleStats.successful}, ` +
        `noLiquidity=${cycleStats.noLiquidity}, simFailed=${cycleStats.simFailed}, txFailed=${cycleStats.txFailed}\n`
    );
  } finally {
    RUNNING = false;
  }
}

/**
 * Returns true if tx was sent (or confirmed).
 */
async function prepareAndSend(wallet, pair) {
  const user = wallet.wallet_address;
  const supply = pair[0];
  const borrow = pair[1];

  console.log(`   üí± Pair: ${supply.symbol} (collateral) ‚Üí ${borrow.symbol} (debt)`);

  // HF re-check right before acting
  const liquidatable = await isLiquidatableOnchain(user);
  if (!liquidatable) {
    cycleStats.notLiquidatable++;
    cooldowns.set(user, Date.now() + COOLDOWN_MS);
    console.log(`   ‚è≠Ô∏è  Skipping: HF >= 1 on-chain now`);
    return false;
  }

  // sizing (close factor)
  const debtAmountHuman = borrow.humanAmount;
  const debtAmountToRepay = Math.min(debtAmountHuman, debtAmountHuman * CLOSE_FACTOR);

  // NOTE: this is still "token units", not USD. Keep for now.
  if (debtAmountToRepay < 1) {
    cycleStats.insufficientSize++;
    console.log(`   ‚è≠Ô∏è  Skipping: debt too small (${debtAmountToRepay} ${borrow.symbol})`);
    return false;
  }

  const debtAmountRawBI = ethers.parseUnits(debtAmountToRepay.toFixed(borrow.decimals), borrow.decimals);

  // Estimate seized collateral size (better than supply*closeFactor guess)
  let estimatedCollateralRaw = null;
  try {
    estimatedCollateralRaw = await estimateCollateralInRaw(
      debtAmountRawBI,
      borrow.decimals,
      borrow.underlying,
      supply.decimals,
      supply.underlying
    );
  } catch {}

  // Cap estimate to user's aToken balance for this collateral
  if (estimatedCollateralRaw != null) {
    const supplyBal = BigInt(supply.amount);
    if (estimatedCollateralRaw > supplyBal) estimatedCollateralRaw = supplyBal;
  }

  // Fallback: old guess if oracle unavailable
  if (estimatedCollateralRaw == null) {
    const collateralAmountToSeize = supply.humanAmount * CLOSE_FACTOR;
    estimatedCollateralRaw = ethers.parseUnits(collateralAmountToSeize.toFixed(supply.decimals), supply.decimals);
  }

  console.log(`   üîÑ Quote: ${supply.symbol} -> ${borrow.symbol}`);
  console.log(`     est amountIn: ${estimatedCollateralRaw.toString()}`);

  // Try a few quote size factors; accept the first that sim-passes.
  for (const factor of QUOTE_SIZE_FACTORS) {
    const amountIn = (estimatedCollateralRaw * BigInt(Math.round(factor * 1000))) / 1000n;

    let swapCalldata = null;
    let amountOutRawBI = 0n;
    let executionTo = null;

    try {
      const quoteResponse = await axios.get(`https://api.liqd.ag/v2/route`, {
        params: {
          tokenIn: supply.underlying,
          tokenOut: borrow.underlying,
          amountIn: amountIn.toString(),
          slippageTolerance: 100, // 1%
        },
        timeout: ROUTE_TIMEOUT_MS,
      });

      swapCalldata = quoteResponse.data?.execution?.calldata;
      executionTo = quoteResponse.data?.execution?.to || null;
      amountOutRawBI = BigInt(quoteResponse.data?.execution?.amountOut || "0");
    } catch (e) {
      cycleStats.noLiquidity++;
      console.log(`   ‚ö†Ô∏è  Quote failed (factor=${factor}): ${String(e?.message || e).slice(0, 160)}`);
      continue;
    }

    if (!swapCalldata || amountOutRawBI === 0n) {
      cycleStats.noLiquidity++;
      console.log(`   ‚è≠Ô∏è  Skipping quote (factor=${factor}): empty / amountOut=0`);
      continue;
    }

    // router safety check (defensive)
    if (cachedRouter && executionTo && String(executionTo).toLowerCase() !== cachedRouter) {
      console.log(`   ‚ö†Ô∏è  Skipping: execution.to mismatch`);
      console.log(`     execution.to: ${String(executionTo).toLowerCase()}`);
      console.log(`     router:       ${cachedRouter}`);
      continue;
    }

    // rough profit check (still rely on staticCall for the real gate)
    const profitBps = calculateProfitBps(amountOutRawBI, debtAmountRawBI);
    console.log(`   üí∞ Profit estimate (factor=${factor}): ${profitBps} bps`);

    if (profitBps < MIN_PROFIT_THRESHOLD_BPS) {
      console.log(`   ‚è≠Ô∏è  Skipping quote: profit ${profitBps} bps < threshold ${MIN_PROFIT_THRESHOLD_BPS} bps`);
      continue;
    }

    console.log(`   ‚úÖ Candidate ok (factor=${factor}) ‚Äî sim/tx...`);
    await sendTxWithCalldata(user, supply.underlying, borrow.underlying, debtAmountRawBI, swapCalldata);

    // If successful it sets a long cooldown.
    if ((cooldowns.get(user) || 0) > Date.now() + (COOLDOWN_SUCCESS_MS / 2)) {
      return true;
    }
  }

  return false;
}

// --------------------
// Entry
// --------------------
async function main() {
  await initializeSigner();

  // Run once immediately
  await run();

  // Then schedule
  cron.schedule("*/5 * * * *", async () => {
    await run();
  });
}

process.on("SIGINT", () => {
  console.log("\n\nüëã Shutting down bot gracefully...");
  process.exit(0);
});

process.on("SIGTERM", () => {
  console.log("\n\nüëã Shutting down bot gracefully...");
  process.exit(0);
});

main().catch((e) => {
  console.error("Fatal:", e);
  process.exit(1);
});
